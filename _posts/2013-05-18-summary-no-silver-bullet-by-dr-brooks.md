---
layout: post
categories: ComputerScience   
title: "Summary: No Silver Bullet by Dr. Brooks"
tags: [ComptuerScience, Opinion, Silver Bullet]
author: Saurab Dulal
---
<style>
body {
text-align: justify;}
</style>
<!-- feature-img: "assets/img/nosilverbullet.jpg" -->
![Silver Bullet](/assets/img/nosilverbullet.jpg "Silver Bullet")
###### *Image Credit: <https://goo.gl/LkSG6K>*    

### **No Silver Bullet**   
   *-Essence and Accident in Software Engineering* 
   
> There is no single development, in either technology or management technique, which by itself promises even one order-of-magnitude improvement within a decade in productivity, in reliability, in simplicity*

Dr Brooks talks about the present status of software development and also about the non-existence 
of fundamental mechanism for the development of software in engineering and programming field.
The development which takes to the present situation of software is due to accident only. He says, most of the big past gains in software productivity have come from removing artificial barriers that have made the accidentals tasks inordinately hard due to awkward programming language, machine time constant, untrained manpower and many more behaves as horrors werewolves. He further says that time has come to think logically about the better silver bullets to cop the present difficulties. 

> Silver bullets were used to kill the werewolves magically because they transform unexpectedly from the familiar into horrors.

There for he says exploiting the mass market, using rapid prototyping, growing software organically and adding more function to the system and finally identifying and developing the great conceptual designers of rising generation could bring huge impact on the software development.
But if we see the present situation and past development then we find no silver bullet. There is no single development in management and technology which promises the order development in productivity and reliability. If we compare the status of hardware then we find far better situation then software, they have fundamental building blocks such as transistors and diodes and their development is also rapid in comparison to software. People have been paying high price for the products but neither they are getting better one nor they are having cheap one. 
Writer argues further that no breakthrough have been seen till the dates but a disciplined, consistent effort to develop, propagate and exploit them should bring a order of improvement then what we have got at present. The development should include the removal of traditional thoughts first and should eliminate the inconsistent method available right now. If we analyze the present situation then we see no sign of bullets that will be available for the future unless the invention of software productivity, reliability, and simplicity.
The hard part of building software has been specification; design and testing of conceptual construct rather not the testing and using it. People have been talking about the syntax error but they seem nothing compared to conceptual errors. Thus, building software has always been hard part because similar things are always eliminated and thus we get huge no of variables to work on.

> Writers consider the following inherent properties of this irreducible essence of modern software systems: complexity, conformity, changeability, and invisibility.

**Complexity:** software design is complex: understanding the main concept and communication between the model and design is very complex one. The main complexity arises because no two parts of software are alike so that there are many variables to deal with and thus it finally become very difficult to code. The problem also arises. Scaling up of a software entity necessarily means a scaling up in components and complexity. The problem is also associated with the work division between the team members and finally it becomes very difficult to make all the members task compatible with one another tasks.  The complexity makes overview hard (seeing and tying up loose ends), and the tremendous learning burden means turnover is costly.

**Invisible:** software is invisible and unvisualiazable. It is very difficult to visualize every part of the expected project because it has no physical structures. It is also very difficult even to visualize since there are many ways to look at the same design: *```“the reality of software is not inherently embedded in space.”```*  This inhibits communication of structure and design.
             
**Changeable:** The main problem seems today in software are lack of changeable property. Changeability means the project should be changed according to requirement and expectation of hardware development. Clearly it should have better compatible with the future technology and development as required by them.
              
**Conformity:** software must conform to external constraints particular to hardware, legacy systems and data, regulations that make it difficult to reduce complexity. The major complexity arises in case or interaction with human system because till now it is arbitrary. Much of the complexity of interacting with human systems is arbitrary, and since software is perceived as changeable, it is most often seen as the thing which should conform, not the human system.
The accidental qualities are all about implementation and testing till the day he have been arguing about the development, and these have been solved almost as well as they are likely to be solved, so don’t expect many more breakthroughs from the accidental one. Here are things that Brooks says have helped to reduce the impact of the accidental qualities around 25 years ago, i.e around in eighties. 
 
High level languages (including object orientation).  One of the most touted recent development in the programming language is the high-level programming approach. The object oriented and general purpose high level language improves the language and also encourage the modern design and modularization. Though the high-level language will not be the ultimate bullet in software development but it is after all, just another high-level language, and the biggest payoff from such languages came from the first transitions, up from the accidental complexity of the machine into more abstract statement of step by step solutions.
Object orientated programming: The object orientated approach means the representation of real world object in the programming. These sorts of processing help to model the real world and also help to create better imagination and design. The concept of abstract data types are developed in this approach which need definition by a name and proper values with proper set of operations. This approach eliminates more accidental difficulty from the process, allowing the designer to express the essence of his design without having to express large syntactic material.

**Artificial intelligence:** If we not know the system and how it works then AI means to make system act like human being and think logically but once you know the system and its working mechanism the AI is just a complex programming which make system to act like it is having some logical output operation. This is also going us to gain a marginal development in building software.

**Time sharing and better OS support:**  Time sharing is contrasted with batch processing, and it helps because we spend much less time in the code and test cycle.  By better OS support, I mean the difference betweeen DOS (which has no library and almost no system call support) and UNIX (which contains many libraries and a vast system call set, allowing you to not have to implement display code, disk drivers, filesystems code, etc.).
writer then talks about hopes for the future to have better platform for development, and discuss all as being silver bullets: Ada and other high-level languages, object orientation, AI (both in the idea of software solving problems that were previously the domain of human intelligence; and in expert systems), expert systems, automatic programming (we specify the requirements and the software writes code for us); graphical programming (a la LabVIEW), proof based  design verification, better tools, and workstations will help in better development in the field.
He further identifies three promising ideas that will help in better software development. 

Buy versus build. Remember that in the mid 1980s, the software market was still small. But the future market would be big as the hardware advances it requires similar software so the market seems wide in coming world.
Incremental, iterative development with feedback from end users: because this helps to refine requirements, prove the design, and improves morale. It also helps in developing communicative software in the future.
Identify, retain and coddle great designers: some people are really just great programmers but remains in one corner, we need to identify them and should just bring them to organizational, they will help to built the better one and also will help to implement good and available logic and resource which will ultimately help in better, fundamental development of software.
Thus Brooks article mostly concentrate on the development of appropriate bullet to rest down the present problems in software development. He suggests there need to be some fundamental basis of it so as mathematics and particle physic is fundaments of natural science. 

He has also related Einstein saying,  *“everything has its fundamental basis”* so he seems searching for the fundamental bullet existing in software development.*

This article is a summary of a paper written by **Dr. Frederick P. Brooks** - The original paper can be downloaded from here <http://worrydream.com/refs/Brooks-NoSilverBullet.pdf>


